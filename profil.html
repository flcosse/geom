<head>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script type="text/javascript">
      $(function(){
      $("#footer").load("footer.html"); 
      });
        </script>
    <link rel="stylesheet" href="style.css">
    <meta charset="utf-8">
    <title>Profil topographique</title>
    <link rel="shortcut icon" href="image/compass-solid.svg" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
  </head>
  <body>
    <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/atom-one-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/python.min.js"></script>
  
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script>
    <div class="container-fluid" id="footer"></div>
      <div class="block">
      <div class="article">
        <h1>Profil topographique avec Rasterio et Shapely</h1>
        <div class="tags">
        <h4> <span class="badge bg-secondary">Python</span></h4>
        <h4> <span class="badge bg-secondary">Rasterio</span></h4>
        <h4> <span class="badge bg-secondary">Shapely</span></h4>
        <h4> <span class="badge bg-secondary">Dash</span></h4>
        <h4> <span class="badge bg-secondary" style="float:none">Leaflet</span></h4>
    </div>
    <div class="textaire">
         <p >Une carte Leaflet permet de récupérer les coordonnées de deux points à partir d'une ligne tracée. Cette ligne servira de base pour récupérer des relevés d'altitude depuis un raster dont les limites sont représentées en bleu. Ensuite ces données sont générées par un graphique. Cliquez sur le symbole de la ligne pour commencer à tracer le profil topographique. Double clic sur le second point pour créer le profil.</p> 
         <ul style="list-style: circle;">
            <li>Le script récupère les coordonnées de l'utilisateur lorsqu'il trace une ligne.</li>
            <li>Ces coordonnées servent à placer une série de points, avec Shapely, plus ou moins dense selon la longueur de la ligne.</li>
            <li>Ces points serviront à prélever les valeurs raster du MNT avec Rasterio.</li>
            <li>Ensuite avec Geopandas les données sont réorganisées dans un geodataframe avec un classement selon une distance croissante.</li>
            <li>Les points sont intégrés à un graphique généré par Plotly.</li>
            <li>Le framework Dash vient assurer la communication entre la carte Leaflet et le graphique.</li>	
            <li>Pour finir, Dash crée l'application avec Dash-leaflet pour la carte, Plotly pour le graphique et un fichier GeoJSON pour délimiter l'emprise du MNT.</li>	
            </ul>
        </div>
         <div class="fi" style="text-align: center">
            <iframe src="http://127.0.0.1:8050/"scrolling="no" style="position:relative;z-index:999;" frameBorder="0" height="150%" width="100%" title=""></iframe>
            
            <div class="spinner-border text-primary" id="spin" role="status"></div>
                <span class="visually-hidden" >Loading...</span>
                <div class="row">
                    <label  id="spintext">En attente d'une ligne...</label>
                  </div>
            
                </div>
         <pre><code class="python">import geopandas as gpd
import numpy as np
import pandas as pd
import rasterio
from pyproj import Geod
from shapely.geometry import LineString
from shapely.ops import unary_union
import plotly.graph_objects as go
from statistics import mean
import math
import dash
from dash import dcc
import dash_leaflet as dl
from dash import html, Output, Input
from scipy.ndimage.filters import uniform_filter1d
from dash_extensions.javascript import arrow_function
import dash_bootstrap_components as dbc

app = dash.Dash(__name__, external_scripts=[dbc.themes.BOOTSTRAP])
server = app.server
app.css.append_css({"external_url": "/assets/stylesheet.css"})
url = 'https://wxs.ign.fr/choisirgeoportail/geoportail/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE=normal&TILEMATRIXSET=PM&FORMAT=image/png&LAYER=GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}'
attribution = '<a target="_blank" href="https://www.geoportail.gouv.fr/">Geoportail France</a>'
config = {
    'toImageButtonOptions': {
        'format': 'svg',
        'filename': 'custom_image',
        'height': 500,
        'width': 700,
        'scale': 1
    },
    'displaylogo': False
}

app.layout = html.Div([
        html.Div([
                dl.Map(
                    center=[44.7904, 4.8065],
                    zoom=8,
                    children=[dl.TileLayer(url=url, maxZoom=20, attribution=attribution),
                        dl.FeatureGroup([dl.EditControl(drawToolbar={"mode": "polyline"}, id="edit_control")]),
                        dl.LayersControl(
                            dl.Overlay(dl.GeoJSON(url="/assets/data.geojson",id="capitals",options=dict(color="#497bff")),
                                name="Zone d'étude",
                                checked=True)
                        ),
                        dl.GeoJSON(
                            id="geojson",
                            hoverStyle=arrow_function(dict(weight=5, color="#666", dashArray="")),
                            options=dict(color="rgb(255, 170, 0)")),
                    ],
                    style={"width": "100%","height": "40vh","margin": "auto","display": "inline-block"},
                    id="mirror",
                )]
        ),
        html.Div([dcc.Graph(
                    id="our_graph",
                    style={"height": "40vh","position": "absolute","width": "98%","display": "none"},
                    config=config
                )]
        )],
    style={"background-color": "rgba(0,0,0,0)"},
)


@app.callback(
    [Output("geojson", "data"),
     Output("our_graph", "figure"),
     Output("our_graph", "style")],
    [Input("edit_control", "geojson")])
def profil(x):
    coord1 = (x["features"][-1]["geometry"]["coordinates"][0][0], x["features"][-1]["geometry"]["coordinates"][0][1])
    coord2 = (x["features"][-1]["geometry"]["coordinates"][1][0], x["features"][-1]["geometry"]["coordinates"][1][1])
    src = rasterio.open(r'raster.tif')
    line = LineString([(coord1[0], coord1[1]), (coord2[0], coord2[1])])
    distances = np.arange(0, line.length, math.log2(Geod(ellps="WGS84").geometry_length(line)) / 100000)
    points = [line.interpolate(distance) for distance in distances] + [line.boundary[1]]
    gdf2 = gpd.GeoDataFrame(index=[0], crs='EPSG:4326', geometry=[unary_union(points)])
    lat = [i.y for i in gdf2["geometry"][0]]
    lon = [i.x for i in gdf2["geometry"][0]]
    df = pd.DataFrame({"Latitude": lat, "Longitude": lon})
    gdf = gpd.GeoDataFrame(df, crs="EPSG:4326", geometry=gpd.points_from_xy(lon,lat))
    gdf['value'] = [x for x in src.sample([(x, y) for x, y in zip(gdf['geometry'].x, gdf['geometry'].y)])]
    gdf = gdf.to_crs(2154)
    dist = [gdf["geometry"][0].distance(i) for i in gdf["geometry"]]
    gdf["Distance"] = dist
    gdf = gdf.sort_values(by='Distance', ascending=True)

    if gdf["Longitude"][0] != coord1[0]:
        gdf = gdf.sort_values(by=['Longitude'], ascending=False)

    gdf['value'] = gdf['value'].astype("float")
    y = gdf["value"].to_list()
    fig = go.Figure(
        data=[
            go.Scatter(
                customdata=np.stack((gdf["Longitude"], gdf["Latitude"]), axis=1),
                x=dist,
                y=uniform_filter1d(y, size=3),
                hovertemplate="Distance : %{x:.0f}m<br>Altitude : %{y:.0f}m<br><extra></extra>",
                fill="tozeroy",
                line_color="rgb(255, 170, 0)",
                mode="lines",
                fillcolor="rgba(255, 170, 0, 0.3)",
                hoverinfo="none",
            )
        ],
    )
    moyenne = mean(y)
    moyenne = round(moyenne, 1)
    maxi = int(float(max(y)))
    pente = round(((y[-1] - y[0]) / max(dist)) * 100, 1)
    fig.update_yaxes(ticks="outside")
    fig.update_xaxes(ticks="outside")
    fig.update(layout_yaxis_range=[0, maxi * 1.5])

    fig.update_xaxes(
        zeroline=True,
        zerolinewidth=2,
        zerolinecolor="#686c69",
        showgrid=True,
        gridwidth=0.1,
        gridcolor="rgba(0,0,0,0)",
    )
    fig.update_yaxes(
        zeroline=True,
        zerolinewidth=2,
        zerolinecolor="#686c69",
        showgrid=True,
        gridwidth=0.1,
        gridcolor="rgba(0,0,0,0)",
    )
    fig.layout.xaxis.fixedrange = True
    fig.layout.yaxis.fixedrange = True
    fig.update_yaxes(title_text="Altitude")
    fig.update_layout(
        {
            "plot_bgcolor": "rgba(255,255,255,0)",
            "paper_bgcolor": "rgba(255,255,255,0)",
        },
        legend_itemdoubleclick=False,
        margin={"r": 0, "l": 0},
        xaxis_title=f"Distance<br><i>Longueur : {int(max(dist))}m / Dénivelé : {round(y[-1] - y[0], 1)}m / Moyenne : {moyenne}m / Pente : {pente}%</i>",
        font=dict(size=11),
        title_text=f"<i>Profil topographique,<br>Départ : {round(y[0])}m - Arrivée : {round(y[-1])}m </i>",
        title_x=0,
        title_y=0.9,
        legend=dict(title=None),
        hoverlabel=dict(
            bgcolor="white",
            bordercolor="rgb(232,232,232)",
            font=dict(
                color="rgb(80,80,80)",
                size=13,
            ),
        ),
    )
    return x, fig, {"height": "auto", "position": "absolute", "width": "100%", "display": "inline"}


if __name__ == "__main__":
    app.run_server(debug=False)
</code></pre>
      </div>
  </div>
  
      </body>